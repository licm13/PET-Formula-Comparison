#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Advanced Spatial Analysis of PET Formulas
==========================================

This script demonstrates the full power of the pet-comparison library by:
1. Using long-term (30-year) gridded climate data
2. Comparing multiple PET formulas across different climate zones
3. Analyzing land cover impacts (including urban areas)
4. Integrating drought analysis using SelfCalibratedPDSI
5. Demonstrating the "drought paradox" effect

Author: Generated by Claude for PET-Formula-Comparison
Date: 2025
"""

import numpy as np
import xarray as xr
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib import colors
from scipy import stats
import sys
import os
from datetime import datetime, timedelta

# Import main library PET formulas
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from pet_comparison.formulas.penman_monteith import penman_monteith
from pet_comparison.formulas.penman_monteith_jarvis import penman_monteith_jarvis
from pet_comparison.formulas.priestley_taylor_jpl import priestley_taylor_jpl
from pet_comparison.formulas.co2_aware import penman_monteith_co2

# Import PDSI for drought analysis
sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '../Xiong_PDSI_025'))
from pdsi_cmip6.pdsi import SelfCalibratedPDSI

# Set random seed for reproducibility
np.random.seed(42)

# Create output directory
OUTPUT_DIR = os.path.join(os.path.dirname(__file__), 'figures')
os.makedirs(OUTPUT_DIR, exist_ok=True)

print("="*80)
print("ADVANCED SPATIAL ANALYSIS OF PET FORMULAS")
print("="*80)
print(f"Output directory: {OUTPUT_DIR}")
print()

# =============================================================================
# PART 1: CREATE SYNTHETIC GRIDDED CLIMATE DATASET (30 years, global scale)
# =============================================================================

print("PART 1: Creating synthetic gridded climate dataset...")
print("-" * 80)

# Spatial dimensions (global grid at 2.5° resolution)
nlat = 72  # -90 to +90, 2.5° resolution
nlon = 144  # -180 to +180, 2.5° resolution
lats = np.linspace(-87.5, 87.5, nlat)
lons = np.linspace(-177.5, 177.5, nlon)

# Temporal dimension (30 years: 1991-2020, monthly data)
start_date = '1991-01-01'
end_date = '2020-12-31'
time = pd.date_range(start=start_date, end=end_date, freq='MS')  # Month start
ntime = len(time)

print(f"  Spatial grid: {nlat}x{nlon} ({nlat*nlon:,} grid points)")
print(f"  Temporal range: {start_date} to {end_date} ({ntime} months)")

# Create coordinate arrays
LAT, LON = np.meshgrid(lats, lons, indexing='ij')
TIME_COORD = np.arange(ntime)

# =============================================================================
# Generate realistic climate variables with spatial and temporal patterns
# =============================================================================

print("  Generating climate variables...")

# 1. Temperature (°C) - latitude and seasonal dependent
def generate_temperature(nlat, nlon, ntime, lats):
    """Generate realistic temperature with latitude gradient and seasonality (vectorized)"""
    # Create coordinate arrays for broadcasting
    months = (np.arange(ntime) % 12) + 1
    seasonal_phase = 2 * np.pi * (months - 1) / 12
    lats_abs = np.abs(lats)

    # Calculate base temperature and seasonal amplitude across latitudes
    base_temp = 30 - 0.6 * lats_abs
    seasonal_amp = 15 * (lats_abs / 90) ** 0.5

    # Use broadcasting to combine time and latitude dimensions
    temp_lat = base_temp[np.newaxis, :] + seasonal_amp[np.newaxis, :] * np.sin(seasonal_phase[:, np.newaxis] - np.pi/2)

    # Add spatial noise and trend
    noise = np.random.normal(0, 2, (ntime, nlat, nlon))
    trend = np.linspace(0, 1.5, ntime)[:, np.newaxis, np.newaxis]
    
    temp = temp_lat[..., np.newaxis] + noise + trend
    return temp

temperature = generate_temperature(nlat, nlon, ntime, lats)

# 2. Relative Humidity (%) - higher in tropics, seasonal variation
def generate_humidity(nlat, nlon, ntime, lats):
    """Generate realistic relative humidity patterns"""
    rh = np.zeros((ntime, nlat, nlon))
    for i, lat in enumerate(lats):
        # Higher humidity in tropics
        base_rh = 70 + 20 * np.exp(-(lat**2) / 1000)

        # Seasonal variation
        for t in range(ntime):
            month = time[t].month
            seasonal_phase = 2 * np.pi * (month - 1) / 12
            seasonal_var = 10 * np.sin(seasonal_phase)

            rh[t, i, :] = base_rh + seasonal_var + np.random.normal(0, 5, nlon)

    return np.clip(rh, 20, 95)

relative_humidity = generate_humidity(nlat, nlon, ntime, lats)

# 3. Wind Speed (m/s) - higher at mid-latitudes
def generate_wind(nlat, nlon, ntime, lats):
    """Generate realistic wind speed patterns"""
    wind = np.zeros((ntime, nlat, nlon))
    for i, lat in enumerate(lats):
        # Higher wind at mid-latitudes (jet stream regions)
        base_wind = 2 + 3 * np.exp(-((abs(lat) - 45)**2) / 500)

        for t in range(ntime):
            wind[t, i, :] = base_wind + np.random.gamma(2, 0.5, nlon)

    return wind

wind_speed = generate_wind(nlat, nlon, ntime, lats)

# 4. Net Radiation (MJ/m²/day) - latitude and seasonal dependent
def generate_radiation(nlat, nlon, ntime, lats):
    """Generate realistic net radiation patterns"""
    radiation = np.zeros((ntime, nlat, nlon))
    for t in range(ntime):
        month = time[t].month
        seasonal_phase = 2 * np.pi * (month - 1) / 12

        for i, lat in enumerate(lats):
            # Higher radiation at low latitudes
            base_rad = 15 - 10 * (abs(lat) / 90)

            # Seasonal variation (Northern Hemisphere)
            if lat >= 0:
                seasonal_rad = 8 * np.sin(seasonal_phase - np.pi/2)
            else:
                seasonal_rad = 8 * np.sin(seasonal_phase + np.pi/2)

            radiation[t, i, :] = base_rad + seasonal_rad + np.random.normal(0, 1, nlon)

    return np.maximum(radiation, 0.1)

net_radiation = generate_radiation(nlat, nlon, ntime, lats)

# 5. Precipitation (mm/month)
def generate_precipitation(nlat, nlon, ntime, lats):
    """Generate realistic precipitation patterns"""
    precip = np.zeros((ntime, nlat, nlon))
    for i, lat in enumerate(lats):
        # Higher precipitation in tropics and mid-latitudes
        base_precip = 100 + 100 * np.exp(-(lat**2) / 800)

        for t in range(ntime):
            month = time[t].month
            seasonal_phase = 2 * np.pi * (month - 1) / 12

            # Seasonal monsoon effect
            seasonal_precip = 50 * np.sin(seasonal_phase) if abs(lat) < 30 else 0

            precip[t, i, :] = base_precip + seasonal_precip + np.random.gamma(2, 20, nlon)

    return np.maximum(precip, 0)

precipitation = generate_precipitation(nlat, nlon, ntime, lats)

# 6. CO2 concentration (ppm) - rising trend
def generate_co2(ntime):
    """Generate realistic CO2 trend (1991-2020)"""
    # Linear increase from ~355 ppm (1991) to ~412 ppm (2020)
    co2 = np.linspace(355, 412, ntime)
    # Add seasonal cycle (~7 ppm amplitude)
    for t in range(ntime):
        month = time[t].month
        seasonal_phase = 2 * np.pi * (month - 1) / 12
        co2[t] += 3.5 * np.sin(seasonal_phase - np.pi)
    return co2

co2_concentration = generate_co2(ntime)

# 7. Climate Zones (Köppen-like classification)
def generate_climate_zones(lats, lons):
    """Generate simplified Köppen climate zones"""
    nlat, nlon = len(lats), len(lons)
    zones = np.zeros((nlat, nlon), dtype=int)

    for i, lat in enumerate(lats):
        if abs(lat) < 15:
            zones[i, :] = 1  # Tropical
        elif abs(lat) < 35:
            zones[i, :] = 2  # Arid/Semi-arid
        elif abs(lat) < 60:
            zones[i, :] = 3  # Temperate
        else:
            zones[i, :] = 4  # Polar

    # Add some spatial heterogeneity
    noise = np.random.randint(0, 2, (nlat, nlon))
    zones = np.where(noise == 1, np.clip(zones + np.random.randint(-1, 2, (nlat, nlon)), 1, 4), zones)

    return zones

climate_zones = generate_climate_zones(lats, lons)

# 8. Land Cover Types
def generate_land_cover(lats, lons, climate_zones):
    """Generate land cover types based on climate zones"""
    nlat, nlon = len(lats), len(lons)
    land_cover = np.zeros((nlat, nlon), dtype=int)

    for i in range(nlat):
        for j in range(nlon):
            zone = climate_zones[i, j]

            # Probabilistic assignment based on climate
            if zone == 1:  # Tropical
                land_cover[i, j] = np.random.choice([1, 2], p=[0.7, 0.3])  # Forest, Cropland
            elif zone == 2:  # Arid
                land_cover[i, j] = np.random.choice([2, 3], p=[0.4, 0.6])  # Cropland, Grassland
            elif zone == 3:  # Temperate
                land_cover[i, j] = np.random.choice([1, 2, 3, 4], p=[0.3, 0.4, 0.2, 0.1])
            else:  # Polar
                land_cover[i, j] = 3  # Grassland/Tundra

    # Add some urban areas (4) near temperate zones
    urban_prob = np.random.random((nlat, nlon))
    land_cover = np.where((climate_zones == 3) & (urban_prob > 0.9), 4, land_cover)

    return land_cover

land_cover = generate_land_cover(lats, lons, climate_zones)

# Create xarray Dataset
print("  Creating xarray Dataset...")
ds = xr.Dataset(
    {
        'temperature': (['time', 'lat', 'lon'], temperature),
        'relative_humidity': (['time', 'lat', 'lon'], relative_humidity),
        'wind_speed': (['time', 'lat', 'lon'], wind_speed),
        'net_radiation': (['time', 'lat', 'lon'], net_radiation),
        'precipitation': (['time', 'lat', 'lon'], precipitation),
        'co2': (['time'], co2_concentration),
        'climate_zone': (['lat', 'lon'], climate_zones),
        'land_cover': (['lat', 'lon'], land_cover),
    },
    coords={
        'time': time,
        'lat': lats,
        'lon': lons,
    },
    attrs={
        'title': 'Synthetic Global Climate Dataset for PET Analysis',
        'description': '30-year (1991-2020) monthly gridded climate data',
        'resolution': '2.5 degrees',
        'author': 'PET-Formula-Comparison',
        'created': datetime.now().isoformat(),
    }
)

# Add variable metadata
ds['temperature'].attrs = {'long_name': 'Air Temperature', 'units': 'degC'}
ds['relative_humidity'].attrs = {'long_name': 'Relative Humidity', 'units': '%'}
ds['wind_speed'].attrs = {'long_name': 'Wind Speed at 2m', 'units': 'm/s'}
ds['net_radiation'].attrs = {'long_name': 'Net Radiation', 'units': 'MJ/m2/day'}
ds['precipitation'].attrs = {'long_name': 'Precipitation', 'units': 'mm/month'}
ds['co2'].attrs = {'long_name': 'CO2 Concentration', 'units': 'ppm'}
ds['climate_zone'].attrs = {
    'long_name': 'Köppen Climate Zone',
    'values': '1=Tropical, 2=Arid, 3=Temperate, 4=Polar'
}
ds['land_cover'].attrs = {
    'long_name': 'Land Cover Type',
    'values': '1=Forest, 2=Cropland, 3=Grassland, 4=Urban'
}

print(f"  Dataset created successfully!")
print(f"  Variables: {list(ds.data_vars)}")
print(f"  Shape: {ds.temperature.shape}")
print()

# =============================================================================
# PART 2: CALCULATE PET USING MULTIPLE FORMULAS
# =============================================================================

print("PART 2: Computing PET using multiple formulas...")
print("-" * 80)

# Prepare common inputs
temp = ds['temperature'].values
rh = ds['relative_humidity'].values
ws = ds['wind_speed'].values
rad = ds['net_radiation'].values
co2 = ds['co2'].values[:, None, None]  # Broadcast to spatial dims

# Calculate atmospheric pressure based on elevation (assume sea level for simplicity)
pressure = 101.3 * np.ones_like(temp)

print("  Computing PM-RC (FAO-56 Reference Crop)...")
pet_pm_rc = penman_monteith(
    temperature=temp,
    relative_humidity=rh,
    wind_speed=ws,
    net_radiation=rad,
    pressure=pressure,
    surface_resistance=70.0
)

print("  Computing PM-CO2 (CO2-aware Penman-Monteith)...")
# For CO2-aware formula, we need to broadcast CO2 properly
# Broadcast the 1D CO2 array to match the 3D climate arrays
co2_broadcasted = co2_concentration[:, np.newaxis, np.newaxis]
pet_pm_co2 = penman_monteith_co2(
    temperature=temp,
    relative_humidity=rh,
    wind_speed=ws,
    net_radiation=rad,
    pressure=pressure,
    co2_concentration=co2_broadcasted,
    co2_reference=355.0,  # 1991 baseline
    surface_resistance=70.0
)

print("  Computing PM-Jarvis (Stomatal conductance model)...")
# PM-Jarvis requires additional vegetation parameters
# We'll use LAI based on land cover
lai = np.where(land_cover == 1, 5.0,  # Forest
       np.where(land_cover == 2, 3.0,  # Cropland
       np.where(land_cover == 3, 1.5, 0.5)))  # Grassland, Urban

# Broadcast the 1D CO2 array to match the 3D climate arrays
co2_broadcasted = co2_concentration[:, np.newaxis, np.newaxis]
pet_pm_jarvis = penman_monteith_jarvis(
    temperature=temp,
    relative_humidity=rh,
    wind_speed=ws,
    net_radiation=rad,
    solar_radiation=rad * 0.6,  # Approximate shortwave
    pressure=pressure,
    co2_concentration=co2_broadcasted,
    lai=lai
)

print("  Computing PT-JPL (Priestley-Taylor JPL)...")
pet_pt_jpl = priestley_taylor_jpl(
    temperature=temp,
    net_radiation=rad,
    pressure=pressure,
    relative_humidity=rh
)

# Add PET results to dataset
ds['pet_pm_rc'] = (['time', 'lat', 'lon'], pet_pm_rc)
ds['pet_pm_co2'] = (['time', 'lat', 'lon'], pet_pm_co2)
ds['pet_pm_jarvis'] = (['time', 'lat', 'lon'], pet_pm_jarvis)
ds['pet_pt_jpl'] = (['time', 'lat', 'lon'], pet_pt_jpl)

# Add metadata
for var in ['pet_pm_rc', 'pet_pm_co2', 'pet_pm_jarvis', 'pet_pt_jpl']:
    ds[var].attrs = {'long_name': f'PET: {var.upper()}', 'units': 'mm/day'}

print(f"  All PET formulas computed successfully!")
print(f"  Available PET variables: {[v for v in ds.data_vars if 'pet_' in v]}")
print()

# =============================================================================
# PART 3: LONG-TERM TREND ANALYSIS (30-year time series)
# =============================================================================

print("PART 3: Long-term trend analysis...")
print("-" * 80)

# Calculate global mean time series for each PET formula
pet_formulas = ['pet_pm_rc', 'pet_pm_co2', 'pet_pm_jarvis', 'pet_pt_jpl']
global_means = {}

for pet_var in pet_formulas:
    # Compute global spatial mean for each time step
    global_means[pet_var] = ds[pet_var].mean(dim=['lat', 'lon']).values

# Convert to annual means
years = np.arange(1991, 2021)
annual_means = {}

for pet_var in pet_formulas:
    # Reshape monthly to annual (12 months x 30 years)
    monthly_data = global_means[pet_var]
    annual_data = monthly_data.reshape(30, 12).mean(axis=1)
    annual_means[pet_var] = annual_data

# Calculate linear trends using Theil-Sen slope estimator (robust to outliers)
print("  Calculating linear trends (Theil-Sen estimator)...")
trends = {}

for pet_var in pet_formulas:
    slope, intercept, _, _ = stats.theilslopes(annual_means[pet_var], years)
    trends[pet_var] = {
        'slope': slope,
        'intercept': intercept,
        'trend_30yr': slope * 30  # Total change over 30 years
    }
    print(f"    {pet_var.upper()}: {slope:.4f} mm/day/year ({slope*30:.2f} mm/day over 30 years)")

# Visualization: Time series with trends
print("  Creating time series plot...")
fig, axes = plt.subplots(2, 2, figsize=(16, 10))
fig.suptitle('30-Year PET Trends (1991-2020): Global Mean Time Series', fontsize=16, fontweight='bold')

colors_pet = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728']
labels = ['PM-RC (FAO-56)', 'PM-CO2', 'PM-Jarvis', 'PT-JPL']

for idx, (pet_var, color, label) in enumerate(zip(pet_formulas, colors_pet, labels)):
    ax = axes.flatten()[idx]

    # Plot annual mean
    ax.plot(years, annual_means[pet_var], 'o-', color=color, linewidth=2,
            markersize=5, label='Annual Mean', alpha=0.8)

    # Plot trend line
    trend_line = trends[pet_var]['slope'] * years + trends[pet_var]['intercept']
    ax.plot(years, trend_line, '--', color='black', linewidth=2,
            label=f'Trend: {trends[pet_var]["slope"]:.4f} mm/day/yr')

    # Formatting
    ax.set_title(label, fontsize=14, fontweight='bold')
    ax.set_xlabel('Year', fontsize=12)
    ax.set_ylabel('PET (mm/day)', fontsize=12)
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.legend(loc='best', fontsize=10)

    # Add statistics text
    stats_text = f'30-yr change: {trends[pet_var]["trend_30yr"]:.2f} mm/day'
    ax.text(0.05, 0.95, stats_text, transform=ax.transAxes,
            fontsize=10, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'pet_longterm_trends.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: pet_longterm_trends.png")
plt.close()

# Comparative plot: All formulas on one axis
fig, ax = plt.subplots(figsize=(14, 6))
ax.set_title('Comparison of PET Formula Trends (1991-2020)', fontsize=16, fontweight='bold')

for pet_var, color, label in zip(pet_formulas, colors_pet, labels):
    ax.plot(years, annual_means[pet_var], 'o-', color=color, linewidth=2.5,
            markersize=6, label=label, alpha=0.8)

ax.set_xlabel('Year', fontsize=14)
ax.set_ylabel('Global Mean PET (mm/day)', fontsize=14)
ax.grid(True, alpha=0.3, linestyle='--')
ax.legend(loc='best', fontsize=12, framealpha=0.9)

plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'pet_trends_comparison.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: pet_trends_comparison.png")
plt.close()

print()

# =============================================================================
# PART 4: SPATIAL ANALYSIS - CO2 Effect Heterogeneity
# =============================================================================

print("PART 4: Spatial analysis of CO2 effect...")
print("-" * 80)

# Calculate long-term annual mean difference: PM-CO2 - PM-RC
pet_diff = ds['pet_pm_co2'].mean(dim='time') - ds['pet_pm_rc'].mean(dim='time')

print("  Creating spatial map of CO2 effect...")
fig, ax = plt.subplots(figsize=(16, 8), subplot_kw={'projection': None})

# Create custom colormap for diverging data
cmap = plt.cm.RdBu_r
norm = colors.TwoSlopeNorm(vmin=-0.5, vcenter=0, vmax=0.5)

# Plot
im = ax.contourf(lons, lats, pet_diff.values, levels=20, cmap=cmap, norm=norm, extend='both')
ax.contour(lons, lats, pet_diff.values, levels=10, colors='black', linewidths=0.3, alpha=0.3)

# Add coastlines approximation
ax.set_xlim(-180, 180)
ax.set_ylim(-90, 90)
ax.set_aspect('auto')  # 'equal' distorts global lat/lon plots

# Formatting
ax.set_xlabel('Longitude', fontsize=14)
ax.set_ylabel('Latitude', fontsize=14)
ax.set_title('CO₂ Effect on PET: Spatial Heterogeneity (PM-CO2 - PM-RC)\n30-Year Annual Mean (1991-2020)',
             fontsize=16, fontweight='bold')
ax.grid(True, alpha=0.3, linestyle='--')

# Colorbar
cbar = plt.colorbar(im, ax=ax, orientation='horizontal', pad=0.05, aspect=40)
cbar.set_label('PET Difference (mm/day)', fontsize=12)

plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'spatial_co2_effect.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: spatial_co2_effect.png")
plt.close()

print()

# =============================================================================
# PART 5: CLIMATE ZONE ANALYSIS (Boxplots by Köppen zones)
# =============================================================================

print("PART 5: Climate zone analysis...")
print("-" * 80)

# Extract climate zones
zones = ds['climate_zone'].values
zone_names = {1: 'Tropical', 2: 'Arid', 3: 'Temperate', 4: 'Polar'}

# Calculate long-term means for each grid point
pet_means_by_formula = {}
for pet_var in pet_formulas:
    pet_means_by_formula[pet_var] = ds[pet_var].mean(dim='time').values.flatten()

# Group by climate zone
zone_flat = zones.flatten()
pet_by_zone = {zone: {pet_var: [] for pet_var in pet_formulas} for zone in range(1, 5)}

for zone_id in range(1, 5):
    mask = (zone_flat == zone_id)
    for pet_var in pet_formulas:
        pet_by_zone[zone_id][pet_var] = pet_means_by_formula[pet_var][mask]

# Create boxplots
print("  Creating climate zone boxplots...")
fig, axes = plt.subplots(2, 2, figsize=(16, 12))
fig.suptitle('PET Variability Across Climate Zones (1991-2020 Mean)',
             fontsize=16, fontweight='bold')

for idx, (pet_var, label) in enumerate(zip(pet_formulas, labels)):
    ax = axes.flatten()[idx]

    # Prepare data for boxplot
    data_for_plot = [pet_by_zone[zone][pet_var] for zone in range(1, 5)]
    zone_labels = [zone_names[z] for z in range(1, 5)]

    # Create boxplot
    bp = ax.boxplot(data_for_plot, labels=zone_labels, patch_artist=True,
                    showmeans=True, meanline=True)

    # Color boxes
    for patch, color in zip(bp['boxes'], ['#ff9999', '#ffcc99', '#99ff99', '#99ccff']):
        patch.set_facecolor(color)
        patch.set_alpha(0.7)

    # Formatting
    ax.set_title(label, fontsize=14, fontweight='bold')
    ax.set_ylabel('PET (mm/day)', fontsize=12)
    ax.set_xlabel('Climate Zone', fontsize=12)
    ax.grid(True, alpha=0.3, axis='y', linestyle='--')

    # Add sample size
    for i, zone in enumerate(range(1, 5)):
        n = len(pet_by_zone[zone][pet_var])
        ax.text(i+1, ax.get_ylim()[1]*0.95, f'n={n}',
                ha='center', fontsize=9, style='italic')

plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'climate_zone_boxplots.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: climate_zone_boxplots.png")
plt.close()

print()

# =============================================================================
# PART 6: LAND COVER IMPACT ANALYSIS
# =============================================================================

print("PART 6: Land cover impact analysis...")
print("-" * 80)

# Extract land cover
lc = ds['land_cover'].values
lc_names = {1: 'Forest', 2: 'Cropland', 3: 'Grassland', 4: 'Urban'}

# Select vegetation-sensitive formulas for comparison
veg_formulas = ['pet_pm_rc', 'pet_pm_jarvis', 'pet_pt_jpl']
veg_labels = ['PM-RC', 'PM-Jarvis', 'PT-JPL']

# Group by land cover
lc_flat = lc.flatten()
pet_by_lc = {lc_id: {pet_var: [] for pet_var in veg_formulas} for lc_id in range(1, 5)}

for lc_id in range(1, 5):
    mask = (lc_flat == lc_id)
    for pet_var in veg_formulas:
        pet_by_lc[lc_id][pet_var] = pet_means_by_formula[pet_var][mask]

# Calculate mean PET by land cover type
print("  Computing mean PET by land cover...")
lc_means = {}
for lc_id in range(1, 5):
    lc_means[lc_id] = {pet_var: np.mean(pet_by_lc[lc_id][pet_var])
                       for pet_var in veg_formulas}
    print(f"    {lc_names[lc_id]:12s}: {', '.join([f'{veg_labels[i]}={lc_means[lc_id][veg_formulas[i]]:.2f}' for i in range(len(veg_formulas))])}")

# Create grouped bar plot
print("  Creating land cover bar plot...")
fig, ax = plt.subplots(figsize=(14, 7))

x = np.arange(len(lc_names))
width = 0.25
colors_veg = ['#3498db', '#e74c3c', '#2ecc71']

for i, (pet_var, label, color) in enumerate(zip(veg_formulas, veg_labels, colors_veg)):
    means = [lc_means[lc_id][pet_var] for lc_id in range(1, 5)]
    ax.bar(x + i*width, means, width, label=label, color=color, alpha=0.8)

# Formatting
ax.set_xlabel('Land Cover Type', fontsize=14, fontweight='bold')
ax.set_ylabel('Mean PET (mm/day)', fontsize=14, fontweight='bold')
ax.set_title('PET Variation Across Land Cover Types\n(30-Year Mean, Including Urban Areas)',
             fontsize=16, fontweight='bold')
ax.set_xticks(x + width)
ax.set_xticklabels([lc_names[i] for i in range(1, 5)], fontsize=12)
ax.legend(loc='best', fontsize=12)
ax.grid(True, alpha=0.3, axis='y', linestyle='--')

plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'land_cover_barplot.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: land_cover_barplot.png")
plt.close()

print()

# =============================================================================
# PART 7: DROUGHT ANALYSIS USING SelfCalibratedPDSI
# =============================================================================

print("PART 7: Drought analysis using SelfCalibratedPDSI...")
print("-" * 80)

# Initialize PDSI calculator
pdsi_calculator = SelfCalibratedPDSI(p0=0.897, q0=1/3, cap=10.0)

# Convert monthly PET (mm/day) to monthly total (mm/month)
days_per_month = np.array([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31])
days_per_month_full = np.tile(days_per_month, 30)  # 30 years

# Prepare inputs for PDSI (P, EP in mm/month)
P_monthly = ds['precipitation'].values  # Already in mm/month
EP_baseline = pet_pm_rc * days_per_month_full[:, None, None]  # PM-RC baseline
EP_adjusted = pet_pm_jarvis * days_per_month_full[:, None, None]  # PM-Jarvis (CO2+VPD sensitive)

print("  Computing PDSI with baseline PET (PM-RC)...")
# For simplified PDSI, we'll use P and EP only (no detailed water balance)
PDSI_baseline = pdsi_calculator.compute(
    P=P_monthly,
    EP=EP_baseline,
    E=None,  # Use simplified mode
    R=None,
    RO=None,
    L=None
)

print("  Computing PDSI with adjusted PET (PM-Jarvis)...")
PDSI_adjusted = pdsi_calculator.compute(
    P=P_monthly,
    EP=EP_adjusted,
    E=None,
    R=None,
    RO=None,
    L=None
)

# Add PDSI to dataset
ds['pdsi_baseline'] = (['time', 'lat', 'lon'], PDSI_baseline)
ds['pdsi_adjusted'] = (['time', 'lat', 'lon'], PDSI_adjusted)

for var in ['pdsi_baseline', 'pdsi_adjusted']:
    ds[var].attrs = {'long_name': f'PDSI: {var}', 'units': 'index'}

print("  ✓ PDSI computed successfully!")

# Calculate global mean PDSI time series
print("  Computing global mean PDSI time series...")
pdsi_baseline_mean = ds['pdsi_baseline'].mean(dim=['lat', 'lon']).values
pdsi_adjusted_mean = ds['pdsi_adjusted'].mean(dim=['lat', 'lon']).values

# Convert to annual means
pdsi_baseline_annual = pdsi_baseline_mean.reshape(30, 12).mean(axis=1)
pdsi_adjusted_annual = pdsi_adjusted_mean.reshape(30, 12).mean(axis=1)

# Calculate trends
slope_baseline, _, _, _ = stats.theilslopes(pdsi_baseline_annual, years)
slope_adjusted, _, _, _ = stats.theilslopes(pdsi_adjusted_annual, years)

print(f"    PDSI Baseline trend: {slope_baseline:.4f} index/year")
print(f"    PDSI Adjusted trend: {slope_adjusted:.4f} index/year")
print(f"    Trend difference: {slope_adjusted - slope_baseline:.4f} index/year")

# =============================================================================
# PART 8: DROUGHT PARADOX VISUALIZATION
# =============================================================================

print()
print("PART 8: Drought paradox visualization...")
print("-" * 80)

# Time series comparison
print("  Creating PDSI time series comparison...")
fig, ax = plt.subplots(figsize=(14, 6))

ax.plot(years, pdsi_baseline_annual, 'o-', color='#e74c3c', linewidth=2.5,
        markersize=7, label='PDSI Baseline (PM-RC)', alpha=0.9)
ax.plot(years, pdsi_adjusted_annual, 's-', color='#2ecc71', linewidth=2.5,
        markersize=7, label='PDSI Adjusted (PM-Jarvis)', alpha=0.9)

# Add trend lines
ax.plot(years, slope_baseline * (years - 1991) + pdsi_baseline_annual[0],
        '--', color='#c0392b', linewidth=2, alpha=0.7,
        label=f'Baseline Trend: {slope_baseline:.4f}/yr')
ax.plot(years, slope_adjusted * (years - 1991) + pdsi_adjusted_annual[0],
        '--', color='#27ae60', linewidth=2, alpha=0.7,
        label=f'Adjusted Trend: {slope_adjusted:.4f}/yr')

# Zero line for reference
ax.axhline(y=0, color='black', linestyle=':', linewidth=1, alpha=0.5)

# Formatting
ax.set_xlabel('Year', fontsize=14, fontweight='bold')
ax.set_ylabel('Global Mean PDSI', fontsize=14, fontweight='bold')
ax.set_title('Drought Paradox: Impact of Vegetation Response on Drought Trends\n(1991-2020)',
             fontsize=16, fontweight='bold')
ax.grid(True, alpha=0.3, linestyle='--')
ax.legend(loc='best', fontsize=12, framealpha=0.9)

# Add interpretation box
paradox_text = (
    "DROUGHT PARADOX EXPLAINED:\n"
    f"• Baseline (PM-RC): {'Drying' if slope_baseline < 0 else 'Wetting'} trend\n"
    f"• Adjusted (PM-Jarvis): {'Drying' if slope_adjusted < 0 else 'Wetting'} trend\n"
    f"• Difference: {abs(slope_adjusted - slope_baseline):.4f} index/yr\n"
    "\n"
    "When accounting for vegetation response to\n"
    "CO₂ and VPD, drought trends can reverse!"
)
ax.text(0.02, 0.98, paradox_text, transform=ax.transAxes,
        fontsize=10, verticalalignment='top',
        bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8, edgecolor='black', linewidth=1.5))

plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'drought_paradox_timeseries.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: drought_paradox_timeseries.png")
plt.close()

# Spatial maps of PDSI trends
print("  Creating spatial PDSI trend maps...")
fig, axes = plt.subplots(2, 1, figsize=(16, 12))

# Calculate trends at each grid point
def calculate_spatial_trend(data):
    """Calculate Theil-Sen slope at each grid point (vectorized over space)."""
    ntime, nlat, nlon = data.shape
    
    # Reshape data to (time, space) for easier iteration
    annual_data = data.reshape(30, 12, nlat * nlon).mean(axis=1)
    
    # Apply theilslopes to each spatial point in a single loop
    slopes = np.array([stats.theilslopes(annual_data[:, i], years)[0] for i in range(nlat * nlon)])
    
    # Reshape slopes back to (lat, lon)
    return slopes.reshape(nlat, nlon)

print("    Computing spatial trends (this may take a moment)...")
trend_baseline = calculate_spatial_trend(PDSI_baseline)
trend_adjusted = calculate_spatial_trend(PDSI_adjusted)

# Plot
cmap_trend = plt.cm.BrBG
vmax_trend = max(abs(trend_baseline.min()), abs(trend_baseline.max()),
                 abs(trend_adjusted.min()), abs(trend_adjusted.max()))
norm_trend = colors.TwoSlopeNorm(vmin=-vmax_trend, vcenter=0, vmax=vmax_trend)

for idx, (trend_data, title) in enumerate(zip(
    [trend_baseline, trend_adjusted],
    ['PDSI Trend: Baseline (PM-RC)', 'PDSI Trend: Adjusted (PM-Jarvis)']
)):
    ax = axes[idx]

    im = ax.contourf(lons, lats, trend_data, levels=20, cmap=cmap_trend, norm=norm_trend, extend='both')
    ax.contour(lons, lats, trend_data, levels=10, colors='black', linewidths=0.3, alpha=0.3)

    ax.set_xlim(-180, 180)
    ax.set_ylim(-90, 90)
    ax.set_aspect('equal')
    ax.set_xlabel('Longitude', fontsize=12)
    ax.set_ylabel('Latitude', fontsize=12)
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.grid(True, alpha=0.3, linestyle='--')

    cbar = plt.colorbar(im, ax=ax, orientation='horizontal', pad=0.05, aspect=40)
    cbar.set_label('PDSI Trend (index/year)', fontsize=11)

fig.suptitle('Spatial Patterns of Drought Trends (1991-2020)', fontsize=16, fontweight='bold', y=0.995)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, 'drought_paradox_spatial.png'), dpi=300, bbox_inches='tight')
print(f"  ✓ Saved: drought_paradox_spatial.png")
plt.close()

print()

# =============================================================================
# PART 9: SUMMARY STATISTICS
# =============================================================================

print("="*80)
print("SUMMARY STATISTICS")
print("="*80)

print("\n1. PET Formula Trends (1991-2020):")
print("-" * 40)
for pet_var, label in zip(pet_formulas, labels):
    trend_val = trends[pet_var]['slope']
    change_30yr = trends[pet_var]['trend_30yr']
    print(f"  {label:20s}: {trend_val:+.4f} mm/day/yr ({change_30yr:+.2f} mm/day total)")

print("\n2. Climate Zone Statistics:")
print("-" * 40)
for zone_id in range(1, 5):
    n_points = np.sum(zones.flatten() == zone_id)
    pct = 100 * n_points / (nlat * nlon)
    print(f"  {zone_names[zone_id]:12s}: {n_points:5d} grid points ({pct:5.1f}%)")

print("\n3. Land Cover Statistics:")
print("-" * 40)
for lc_id in range(1, 5):
    n_points = np.sum(lc.flatten() == lc_id)
    pct = 100 * n_points / (nlat * nlon)
    print(f"  {lc_names[lc_id]:12s}: {n_points:5d} grid points ({pct:5.1f}%)")

print("\n4. Drought Paradox Metrics:")
print("-" * 40)
print(f"  PDSI Baseline trend:  {slope_baseline:+.4f} index/year")
print(f"  PDSI Adjusted trend:  {slope_adjusted:+.4f} index/year")
print(f"  Paradox magnitude:    {abs(slope_adjusted - slope_baseline):.4f} index/year")
if (slope_baseline < 0) != (slope_adjusted < 0):
    print(f"  ⚠ TREND REVERSAL DETECTED!")
else:
    print(f"  ℹ No trend reversal, but magnitude differs")

print("\n5. Output Files Generated:")
print("-" * 40)
output_files = [
    'pet_longterm_trends.png',
    'pet_trends_comparison.png',
    'spatial_co2_effect.png',
    'climate_zone_boxplots.png',
    'land_cover_barplot.png',
    'drought_paradox_timeseries.png',
    'drought_paradox_spatial.png',
]
for i, fname in enumerate(output_files, 1):
    print(f"  {i}. {fname}")

print("\n" + "="*80)
print("ANALYSIS COMPLETE!")
print("="*80)
print(f"\nAll outputs saved to: {OUTPUT_DIR}")
print("\nThis advanced analysis demonstrates:")
print("  ✓ Long-term (30-year) gridded PET calculations")
print("  ✓ Multiple PET formulas with different physical assumptions")
print("  ✓ Spatial heterogeneity of CO₂ effects")
print("  ✓ Climate zone and land cover dependencies")
print("  ✓ Integration of drought indices (PDSI)")
print("  ✓ Evidence of the 'drought paradox'")
print("\nThank you for using the PET-Formula-Comparison library!")
print("="*80)
